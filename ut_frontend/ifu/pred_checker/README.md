# PredChecker 单元验证

## 测试目标

PredChecker的功能是从IFU接收pc和PreDecode的译码信息，以及BPU的预测结果，针对前述内容检查5种简单的预测错误，并修正预测结果。输出分为两阶段，第一阶段返回修复的指令范围和修复的跳转指令选取情况，第二阶段返回修复的顺序目标、跳转目标和指令错误预测情况

测试基本流程为：

TBD

## 测试环境 Env

本测试基于toffee封装测试环境。

其中，对DUT的数据职责封装由bundle完成，可参见当前目录下的bundle目录。

对DUT的行为抽象由本目录下的agent目录完成，提供一个接口agent_pred_check，该接口采用了yield分阶段返回，第一阶段返回的是修复的指令范围和修复的跳转指令选取情况，第二阶段返回的是修复的顺序目标、跳转目标和指令错误预测情况。

## 功能点和测试点

| 序号     | 功能                 | 名称                 | 描述                                                                                            |
|--------|--------------------|--------------------|-----------------------------------------------------------------------------------------------|
| 1\.1\.1 | BPU预测信息的JAL预测错误检查  | 误检测试1              | 预测块中没有JAL指令且最终预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。                               |
| 1\.1\.2 | BPU预测信息的JAL预测错误检查  | 误检测试2              | 预测块中有JAL指令且最终预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。                                |
| 1\.2\.1 | BPU预测信息的JAL预测错误检查  | 存在JAL未预测           | 预测块中存在JAL指令，但是最终预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。 |
| 1\.2\.2 | BPU预测信息的JAL预测错误检查  | 预测的JAL并非第一条        | 预测块中存在JAL指令，但是最终预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。 |
| 2\.1\.1 | BPU预测信息的RET预测错误检查  | 误检测试1              | 预测块中没有RET指令且最终预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。                               |
| 2\.1\.2 | BPU预测信息的RET预测错误检查  | 误检测试2              | 预测块中有RET指令且最终预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。                                |
| 2\.2\.1 | BPU预测信息的RET预测错误检查  | 存在RET未预测           | 预测块中存在RET指令，但是最终预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。                                     |
| 2\.2\.2 | BPU预测信息的RET预测错误检查  | 预测的跳转并非第一条         | 预测块中存在RET指令，但是最终预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。                         |
| 3\.1   | 更新指令有效范围向量和预测跳转的指令 | 有效范围无误             | 不存在任何错误的情况下，PredChecker应当保留之前的预测结果。                                                       |
| 3\.2   | 更新指令有效范围向量和预测跳转的指令 | RET和JAL预测错误引起的范围偏大 | 如果检测到了JAL或RET类的预测错误，PredChecker应该将有效指令的范围修正为预测块开始至第一条跳转指令。同时，应该将预测跳转的指令位置修正为预测块中的第一条跳转指令。 |
| 3\.3   | 更新指令有效范围向量和预测跳转的指令 | 非CFI和无效指令引起的预测范围偏小 | 如果出现了非控制流指令和无效指令的误预测，应该将预测跳转的指令重新修正到预测块中第一条跳转指令                      |
| 4\.1\.1 | 非CFI预测错误检查         | 误检测试1              | 构造不存在CFI指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误                |
| 4\.1\.2 | 非CFI预测错误检查         | 误检测试2              | 构造存在CFI指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误                |
| 4\.2   | 非CFI预测错误检查         | 正确检测测试             | 构造不存在CFI指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出非CFI预测错误               |
| 5\.1\.1 | 无效指令预测错误检查         | 误检测试1              | 构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误                 |
| 5\.1\.2 | 无效指令预测错误检查         | 误检测试2              | 构造存在无效跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误                |
| 5\.1\.3 | 无效指令预测错误检查         | 误检测试3              | 构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误               |
| 5\.2   | 无效指令预测错误检查         | 正确检测测试             | 构造无效指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出无效指令预测错误                   |
| 6\.1\.1 | 目标地址预测错误检查         | 误检测试1              | 构造不存在跳转指令并且未预测跳转的预测信息作输入，测试PredChecker是否会错检目标地址预测错误                  |
| 6\.1\.2 | 目标地址预测错误检查         | 误检测试2              | 构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误          |
| 6\.2   | 目标地址预测错误检查         | 正确检测测试             | 构造存在有效跳转指令的预测块和预测跳转但跳转目标计算错误的预测信息作为输入，测试PredChecker能否检出目标地址预测错误 |
| 7\.1   | 生成跳转和顺序目标          | 随机测试               | 随机提供译码信息，检测生成的跳转目标和顺序目标。 |



## Env提供的验证接口(API)

为了让测试用例更通用，具有继承性，本Env提供的接口**对外屏蔽了电路引脚和时序，且接口保持稳定**：

## 用例说明

TBD

## 检查列表

- [ ] 本文档符合指定[模板]()要求
- [ ] Env提供的API不包含任何DUT引脚和时序信息
- [ ] Env的API保持稳定（共有[ X ]个）
- [ ] Env中对所支持的RTL版本（支持版本[ X ]）进行了检查
- [ ] 功能点（共有[ X ]个）与[设计文档]()一致
- [ ] 检查点（共有[ X ]个）覆盖所有功能点
- [ ] 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API
- [ ] 所有测试用例（共有[ X ]个）都对功能检查点进行了反标
- [ ] 所有测试用例都是通过 assert 进行的结果判断
- [ ] 所有DUT或对应wrapper都是通过fixture创建
- [ ] 在上述fixture中对RTL版本进行了检查
- [ ] 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计
- [ ] 设置代码行覆盖率时对过滤需求进行了检查

## TODO

测试用例

参考模型

文档：测试流程