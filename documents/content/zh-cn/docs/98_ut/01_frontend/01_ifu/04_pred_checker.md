---
title: PredChecker
linkTitle: PredChecker
weight: 12
---

<div class="ifu-ctx">

# 子模块：PredChecker简介

分支预测检查器PredChecker接收来自IFU的预测块信息（包括预测跳转指令在预测块的位置、预测的跳转目标、预译码得到的指令信息、指令PC以及预译码得到的跳转目标偏移等），在模块内部检查五种类型的分支预测错误。模块内部分为两个流水线stage，分别输出信息，第一个stage输出给IFU的f3阶段，用于修正预测块的指令范围和预测结果。第二个stage输出给wb阶段，用于在发现分支预测错误时产生前端重定向以及写回给FTQ（Fetch Target Queue）正确的预测信息。

## PredChecker功能介绍

### JAL预测错误检查

jal指令预测错误的条件是，预测块中有一条有效jal指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jal指令之后（即这条jal指令没有被预测跳转）。

### JALR预测错误检查

jalr指令预测错误的条件是，预测块中有一条有效jalr指令（由预译码信息给出），而且这个指令不是ret指令，但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jalr指令之后（即这条jalr指令没有被预测跳转）。

### RET预测错误检查

ret指令预测错误的条件是，预测块中有一条有效ret指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条ret指令之后（即这条ret指令没有被预测跳转）。

### 更新指令有效范围向量

PredChecker在检查出Jal/Ret/JALR指令预测错误时，需要重新生成指令有效范围向量，有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。
需要注意的是，jal和ret指令的错误检查都会导致指令有效范围的缩短，
所以需要重新生成指令有效范伟fixedRange，同时修复预测结果。需要注意的是，这个修复只会针对RET预测错误和JAL预测错误导致的范围错误，对于后续要介绍的非CFI（控制流指令）预测错误和无效指令预测错误，尽管他们会造成预测块的范围偏小，但是不会进行修复，而是直接在这里进行重定向。这样，重定向后重新取的指令会从这个出错的指令开始。

### 非CFI预测错误检查

非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。

### 无效指令预测错误检查

无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。

### 目标地址预测错误检查

目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。

### 分级输出检查结果

以上PredChecker检查结果会分为两级分别输出，前面已经提到，Jal/Ret指令由于需要重新生成指令有效范围向量和重新指定预测位置，
所以需要在错误产生的当拍（F3）直接输出结果到Ibuffer用于及时更正进入后端的指令 。而由于时序的考虑，其他错误信息（比如五种错误的错误位置、正确的跳转地址等）则是等到下一拍（WB）阶段才返回给IFU做前端重定向。

## PredChecker接口说明

### 输入接口

fire\_in：这个信号可以简单认为是模块有效性的控制信号。

ftqOffset：来自BPU（分支预测单元）的预测信息，表示该预测块的跳转指令是否存在（valid），以及跳转指令的序号（bits）。

instrRange：来自PreDecode的预译码信息，对每条指令，表示该指令是否在预测块的有效指令范围内。

instrValid：来自PreDecode的预译码信息，表示的是对于每条32位的拼接指令，其是否为一条有效的指令（即低16位为一条RVC指令，或者整个32位为一条RVI指令）。

jumpOffset：来自PreDecode的预译码信息，如果某一指令为跳转指令，jumpOffset表示这个指令的跳转目标。

pc：指令的pc。

pds：来自PreDecode模块的预译码信息，包含指令的brType、是否为Ret（isRet）、是否为RVC指令（isRVC）。

target：来自BPU，下个预测块的开始地址。

### 输出接口

#### 第一阶段输出

fixedRange：修复的指令有效范围向量，对每条指令i，fixedRange_i为真表示这条指令是否在当前预测块的有效指令范围内

fixedTaken：修复过后的CFI指令选取情况，对每条指令，fixedTaken_i为真表示这条指令是否是这个预测块的第一条CFI指令

#### 第二阶段输出

fixedMissPred：对每条指令，PredChecker检查出的存在预测错误的情况，fixedMissPred_i为真表示这条指令存在预测错误

fixedTarget：对每条指令，给出修复过的下一条指令的位置（可以是常规的pc+2或+4，或者如果是跳转指令，给出跳转目标）。

jalTarget：对每条指令，给出跳转目标。

faultType：每条指令的错误类型，取指范围包含noFault，jalFault，retFault，targetFault，notCFIFault，invalidTaken，jalrFault，分别对应数字0～6

## PredChecker测试点和功能点

### 功能点1 BPU预测信息的JAL预测错误检查

PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。

对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。

对于误检，我们设计如下的测试点:

| 序号       | 名称    | 描述                                                             |
|----------|-------|----------------------------------------------------------------|
| 1\.1\.1  | 误检测试1 | 预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 |
| 1\.1\.2  | 误检测试2 | 预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。  |

对于JAL预测错误的正确检验，我们设计如下的测试点：

| 序号     | 名称          | 描述                                                     |
|--------|-------------|--------------------------------------------------------|
| 1\.2\.1 | 存在JAL未预测    | 预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。 |
| 1\.2\.2 | 预测的JAL并非第一条 | 预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。 |

### 功能点2 BPU预测信息的RET预测错误检查

PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。

和JAL预测错误类似，我们也按照误检和正检来构造。

对于误检，我们设计如下的测试点：

| 序号| 名称     | 描述                                                               |
|-----|--------|------------------------------------------------------------------|
| 2\.1\.1| 误检测试1  | 预测块中没有RET指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。 |
| 2\.1\.2| 误检测试2  | 预测块中有RET指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。  |

对于RET预测错误的正确检出，我们设计如下的测试点：

| 序号    | 名称              | 描述                                                   |
|-------|-----------------|------------------------------------------------------|
| 2\.2\.1| 存在RET未预测        | 预测块中存在RET指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。           |
| 2\.2\.2| 预测的跳转并非第一条 | 预测块中存在RET指令，但是BPU预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。 |

### 功能点3 BPU预测信息的JALR预测错误检查

PredChecker会对传入的预测块进行JALR预测错误预检查并修正指令有效范围向量和新的预测结果。

和JAL/RET预测错误类似，我们也按照误检和正检来构造。

对于误检，我们设计如下的测试点：

| 序号| 名称     | 描述                                                               |
|-----|--------|------------------------------------------------------------------|
| 3\.1\.1| 误检测试1  | 预测块中没有JALR指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JALR预测错误。 |
| 3\.1\.2| 误检测试2  | 预测块中有JALR指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JALR预测错误。  |

对于JALR预测错误的正确检出，我们设计如下的测试点：

| 序号    | 名称              | 描述                                                   |
|-------|-----------------|------------------------------------------------------|
| 3\.2\.1| 存在JALR未预测   | 预测块中存在JALR指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。           |
| 3\.2\.2| 预测的跳转并非第一条 | 预测块中存在JALR指令，但是BPU预测信息取的跳转指令在第一条JALR指令之后，检查PredChecker是否能检测出JALR预测错误。 |

### 功能点4 更新指令有效范围向量和预测跳转的指令
PredChecker在检查出Jal/Ret/Jalr指令预测错误时，需要重新生成指令有效范围向量，
有效范围截取到Jal/Ret/Jalr指令的位置，之后的bit全部置为0。
同时，还需要根据每条指令的预译码信息和BPU的预测信息修复预测跳转的结果。

所以，根据功能要求，我们可以划分出三类情况，分别是预测的有效范围和取用的跳转指令正确的情况，
由于RET和JAL预测错误引起的有效范围偏大和错判非跳转指令和无效指令引起的有效范围偏小。

| 序号   | 名称                      | 描述   |
|---------|-------------------------|---------------------------------------------------------------|
| 4\.1 | 有效范围无误                  | 不存在任何错误的情况下，PredChecker应当保留之前的预测结果。        |
| 4\.2 | RET、JAL、JALR预测错误引起的范围偏大 | 如果检测到了JAL、RET、JALR类的预测错误，PredChecker应该将有效指令的范围修正为预测块开始至第一条跳转指令。同时，应该将预测跳转的指令位置修正为预测块中的第一条跳转指令。 |
| 4\.3 | 非CFI和无效指令引起的预测范围偏小 | 如果出现了非控制流指令和无效指令的误预测，不应该将预测跳转的指令重新修正到预测块中第一条跳转指令，因为后续会直接冲刷并重新从重定向的位置取指令，如果这里修正的话，会导致下一预测块传入重复的指令 |


### 功能点5 非CFI预测错误检查

非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。

要检验这一功能，我们仍然按误检和正确检验来设计测试点：

| 序号    | 名称    | 描述                                                    |
|-------|-------|-------------------------------------------------------|
| 5\.1\.1 | 误检测试1 | 构造不存在CFI指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误 |
| 5\.1\.2 | 误检测试2 | 构造存在CFI指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误 |
| 5\.2 | 正确检测测试 | 构造不存在CFI指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出非CFI预测错误|

### 功能点6 无效指令预测错误检查
无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。

要检验这一功能，我们按照误检和正确检测来设计测试点：

| 序号 | 名称        | 描述                                                         |
|------|-----------|------------------------------------------------------------|
| 6\.1\.1| 误检测试1     | 构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误  |
| 6\.1\.2| 误检测试2 | 构造存在无效跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误 |
| 6\.1\.3| 误检测试3 | 构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误 |
| 6\.2| 正确检测测试    | 构造无效指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出无效指令预测错误 |

### 功能点7 目标地址预测错误检查
目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，
同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。

和先前的思路一样，我们仍然按误检和检出两类组织测试点：

| 序号   | 名称       | 描述                                                        |
|------|----------|-----------------------------------------------------------|
| 7\.1\.1 | 误检测试1    | 构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误                |
| 7\.1\.2 | 误检测试2    | 构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误         |
| 7\.2 | 正确检测测试   | 构造存在有效跳转指令的预测块和预测跳转但跳转目标计算错误的预测信息作为输入，测试PredChecker能否检出目标地址预测错误 |

### 功能点8 生成跳转和顺序目标
PredChecker还需要负责生成跳转和顺序目标。

我们通过随机生成译码信息进行测试

| 序号 | 名称   | 描述                                                        |
|-----|------|-----------------------------------------------------------|
| 8\.1| 随机测试 | 随机提供译码信息，检测生成的跳转目标和顺序目标。 |



## <a id="pred_checker_functions">测试点汇总</a>
综上所述，所有的测试点如下：

| 序号     | 功能                 | 名称                 | 描述                                               |
|--------|--------------------|--------------------|-----------------------------------------------------------------------------------------------|
| 1\.1\.1 | BPU预测信息的JAL预测错误检查  | 误检测试1              | 预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。                               |
| 1\.1\.2 | BPU预测信息的JAL预测错误检查  | 误检测试2              | 预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。                                |
| 1\.2\.1 | BPU预测信息的JAL预测错误检查  | 存在JAL未预测           | 预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。 |
| 1\.2\.2 | BPU预测信息的JAL预测错误检查  | 预测的JAL并非第一条        | 预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。 |
| 2\.1\.1 | BPU预测信息的RET预测错误检查  | 误检测试1              | 预测块中没有RET指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。                               |
| 2\.1\.2 | BPU预测信息的RET预测错误检查  | 误检测试2              | 预测块中有RET指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。                                |
| 2\.2\.1 | BPU预测信息的RET预测错误检查  | 存在RET未预测           | 预测块中存在RET指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。                                     |
| 2\.2\.2 | BPU预测信息的RET预测错误检查  | 预测的跳转并非第一条         | 预测块中存在RET指令，但是BPU预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。                         |
| 3\.1\.1| BPU预测信息的JALR预测错误检查 |误检测试1  | 预测块中没有JALR指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JALR预测错误。 |
| 3\.1\.2| BPU预测信息的JALR预测错误检查 |误检测试2  | 预测块中有JALR指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JALR预测错误。  |
| 3\.2\.1| BPU预测信息的JALR预测错误检查 | 存在JALR未预测   | 预测块中存在JALR指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。           |
| 3\.2\.2| BPU预测信息的JALR预测错误检查 | 预测的跳转并非第一条 | 预测块中存在JALR指令，但是BPU预测信息取的跳转指令在第一条JALR指令之后，检查PredChecker是否能检测出JALR预测错误。 |
| 4\.1   | 更新指令有效范围向量和预测跳转的指令 | 有效范围无误             | 不存在任何错误的情况下，PredChecker应当保留之前的预测结果。                                                       |
| 4\.2   | 更新指令有效范围向量和预测跳转的指令 | RET和JAL预测错误引起的范围偏大 | 如果检测到了JAL或RET类的预测错误，PredChecker应该将有效指令的范围修正为预测块开始至第一条跳转指令。同时，应该将预测跳转的指令位置修正为预测块中的第一条跳转指令。 |
| 4\.3   | 更新指令有效范围向量和预测跳转的指令 | 范围偏小不修正 |如果出现了非控制流指令和无效指令的误预测，不应该将预测跳转的指令重新修正到预测块中第一条跳转指令，因为后续会直接冲刷并重新从重定向的位置取指令，如果这里修正的话，会导致下一预测块传入重复的指令。|
| 5\.1\.1 | 非CFI预测错误检查         | 误检测试1              | 构造不存在CFI指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误                |
| 5\.1\.2 | 非CFI预测错误检查         | 误检测试2              | 构造存在CFI指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误                |
| 5\.2   | 非CFI预测错误检查         | 正确检测测试             | 构造不存在CFI指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出非CFI预测错误               |
| 6\.1\.1 | 无效指令预测错误检查         | 误检测试1              | 构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误                 |
| 6\.1\.2 | 无效指令预测错误检查         | 误检测试2              | 构造存在无效跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误                |
| 6\.1\.3 | 无效指令预测错误检查         | 误检测试3              | 构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误               |
| 6\.2   | 无效指令预测错误检查         | 正确检测测试             | 构造无效指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出无效指令预测错误                   |
| 7\.1\.1 | 目标地址预测错误检查         | 误检测试1              | 构造不存在跳转指令并且未预测跳转的预测信息作输入，测试PredChecker是否会错检目标地址预测错误                  |
| 7\.1\.2 | 目标地址预测错误检查         | 误检测试2              | 构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误          |
| 7\.2   | 目标地址预测错误检查         | 正确检测测试             | 构造存在有效跳转指令的预测块和预测跳转但跳转目标计算错误的预测信息作为输入，测试PredChecker能否检出目标地址预测错误 |
| 8\.1   | 生成跳转和顺序目标          | 随机测试               | 随机提供译码信息，检测生成的跳转目标和顺序目标。 |

</div>