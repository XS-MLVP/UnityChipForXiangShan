---
title: PreDecode
linkTitle: PreDecode
weight: 12
---

<div class="ifu-ctx">

# 子模块：PreDecoder简介

预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。

所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。

预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）

### 功能介绍

### 指令码生成

预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度，
从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。

### 预译码信息生成

预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、
CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。

首先是判断是否是RVC指令，RVC指令的具体格式参阅RISCV手册的描述：

![RVC](RVCtable.png)

其中，决定指令是否为RVC的部分在于指令的\[1, 0\]两位，不为3的情况下都是RVC指令。

其余的指令性质判定功能（CFI类型、是否为call和ret）被时序优化到了F3PreDecoder中，不过也可以认为是PreDecoder的一部分，可以设置测试点进行测试

最后比较麻烦的是CFI指令的目标地址计算偏移，主要是对J和BR分支指令进行的计算，这需要综合RVI和RVC中jal和br指令的结构。
首先，是手册中对于C.J的描述

![JOP](JOP.png)

这里对imm立即数的注解是，立即数的每一位最后对应到的是偏移的哪一位。


所以，可以认为立即数是这么重组的：

instr(12) + instr(8) + instr(10, 9) + instr(6) + instr(7) + instr(2) + instr(11) +instr(5,3) + "0"

而RVI中，对于JAL指令，是这么定义的：

![RVIJ](RVIJ.png)

我们可以类似地计算立即数。

同样的，我们可以查询手册，参考BR类指令的立即数计算RVC和RVI指令对应的偏移。

![RVIBR](RVIBR.png)

![RVCBR](RVCBR.png)

## PreDecode接口说明

### 输入接口

in\_bits\_data 17 x 2B的初始指令码，其中，每2个字节既可以代表一条RVC指令，也可以代表一个RVI指令的一半。

### 输出接口

instr：拼接后的 16 x 4B的初始指令码

jumpOffset：如果这条指令是跳转指令，则jumpOffset表示其跳转偏移

pd：每条指令预译码信息，包括valid、isRVC、brType、isRet、isCall。其中第0条指令的valid已经被优化了

hasHalfValid：这个信号需要和pd的valid结合起来看，PreDecode的一个功能是求出指令开始向量，也就是对每个4B的拼接指令，判断其低2B是否为一条有效指令的开始（即一条RVI指令的前半部分，或者一条RVC指令），但是需要分类讨论该预测块的第一个2B是否为一条有效指令的开始。hasHalfValid表示的是当前预测块的第一个2B指令为一条RVI指令的后半部分时，给出的指令开始向量。类似地，pd中的valid指的是当前预测块的第一个2B指令为一条指令的开始时，给出的指令开始向量。

## PreDecoder测试点和功能点

### 功能点1 生成指令码
子模块：PreDecoder简介

预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。

所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。

预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）
功能介绍
指令码生成

预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。
预译码信息生成

预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。

预译码器从IFU接收完成指令切分的17 x 2 字节的初始指令码，以4字节为窗口，2字节为步进长度，选出16 x 4字节的指令码

我们需要随机生成初始指令码，并测试拼接的结果。

| 序号| 名称   | 描述                           |
|---|------|------------------------------|
| 1 | 拼接测试 | 随机生成17 x 2字节的初始指令码，检验PreDecoder拼接结果 |

### 功能点2 生成预译码信息

预译码器会根据指令码产生预译码信息，包括RVC指令的判定和CFI指令的目标地址计算偏移。

CFI类型的判定则时序优化到了F3PreDecoder中。
可以设计测试点测试PreDecode对F3PreDecoder的使用。

据此，我们可以设计下述测试点。

首先是判定RVC指令，我们随机生成输入初始指令码，对返回的16位RVC判定结果进行检验。
具体来说，对每32位指令，考虑RVC和RVI两种情况。

| 序号   | 名称    | 描述              |
|------|-------|-----------------|
| 2\.1\.1 | RVC判定 | 传入RVC指令，应该判断为RVC |
| 2\.1\.2 | RVI判定 | 传入RVI指令，不应判断为RVC |

然后，需要分别根据手册构造RVC和RVI扩展下的J指令和BR指令们，所以有如下的测试点：

| 序号 | 名称         | 描述                      |
|-----|------------|-------------------------|
| 2\.2\.1| RVC\.J计算   | 对传入RVC扩展的J指令，检查计算的偏移  |
| 2\.2\.2| RVI\.J计算   | 对传入RVI扩展的J指令，检查计算的偏移  |
| 2\.2\.3| RVC\.BR计算  | 对传入RVC扩展的BR指令，检查计算的偏移 |
| 2\.2\.4|  RVI\.BR计算 | 对传入RVI扩展的BR指令，检查计算的偏移 |

参照F3PreDecoder的测试点，设计如下测试点：

| 序号 | 名称     | 描述                                 |
|-----|--------|------------------------------------|
| 2\.3\.1| 非CFI判定 | 对传入的非CFI指令（包括RVC\.EBREAK），应该判定为类型0 |
| 2\.3\.2| BR判定   | 对传入的BR指令，应该判定为类型1   |
| 2\.3\.3| JAL判定  | 对传入的JAL指令，应该判定为类型2  |
| 2\.3\.4| JALR判定 | 对传入的JALR指令，应该判定为类型3 |
| 2\.4\.1 | 非CFI和BR不判定       | 对传入的非CFI和BR指令，都不应判定为call或者ret                  |
| 2\.4\.2\.1\.1 | RVI\.JAL判定call | 对传入的RVI\.JAL指令，当rd设置为1或5，应当判定该指令为call          |
| 2\.4\.2\.1\.2 | RVI\.JAL例外    | 对传入的RVI\.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret |
| 2\.4\.2\.2 | RVC\.JAL不判定   | 对传入的RVC\.JAL指令，无论什么情况都不能判定为call或ret    |
| 2\.4\.3\.1\.1 | RVI\.JALR和rd为link     | 传入RVI\.JALR指令，并且rd为1或5，无论其他取值，都应判定为call     |
| 2\.4\.3\.1\.2 | RVI\.JALR且仅rs为link    | 传入RVI\.JALR指令，rd不为1和5，rs为1或5，应判定为ret        |
| 2\.4\.3\.1\.3 | RVI\.JALR无link        | 对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal |
| 2\.4\.3\.2\.1 | RVC\.JALR为Ret | 传入RVC\.JALR指令，必定为call     |
| 2\.4\.3\.2\.2\.1 | RVC\.JR且rs为link    | 传入RVC\.JR指令，rs为1或5，应判定为ret        |
| 2\.4\.3\.2\.2\.2 | RVC\.JR且rs不为link    | 传入RVC\.JR指令，rs不为1或5，不应判定为ret        |

### 功能点3 生成指令开始向量

最后，预译码还需要生成两种指令开始向量：
| 序号 | 名称         | 描述                      |
|-----|------------|-------------------------|
| 2\.3\.1| 有效指令开始向量计算1   | 对预测块，假定第一条指令为一条有效指令的开始，对每条指令计算其是否为有效指令开始  |
| 2\.3\.2| 有效指令开始向量计算2   | 对预测块，假定第一条指令为一条有效指令的结束，对每条指令计算其是否为有效指令开始  |


## **测试点汇总**<a id="pred_decoder_functions"> </a>

综上所述，对PredDecoder，所有的测试点为：

| 序号 | 功能     | 名称         | 描述                                  |
|---|--------|------------|-------------------------------------|
| 1| 拼接指令码  | 拼接测试 | 随机生成17 x 2字节的初始指令码，检验PreDecoder拼接结果 |
| 2\.1\.1| RVC判定  | RVC判定 | 传入RVC指令，应该判断为RVC |
| 2\.1\.2| RVC判定  | RVI判定 | 传入RVI指令，不应判断为RVC |
| 2\.2\.1| 跳转目标计算 | RVC\.J计算  | 对传入RVC扩展的J指令，检查计算的偏移  |
| 2\.2\.2| 跳转目标计算 | RVI\.J计算  | 对传入RVI扩展的J指令，检查计算的偏移  |
| 2\.2\.3| 跳转目标计算 | RVC\.BR计算 | 对传入RVC扩展的BR指令，检查计算的偏移 |
| 2\.2\.4| 跳转目标计算 | RVI\.BR计算 | 对传入RVI扩展的BR指令，检查计算的偏移 |
| 2\.3\.1| CFI指令类型判定 |非CFI判定 | 对传入的非CFI指令（包括RVC\.EBREAK），应该判定为类型0 |
| 2\.3\.2| CFI指令类型判定 | BR判定   | 对传入的BR指令，应该判定为类型1   |
| 2\.3\.3| CFI指令类型判定 | JAL判定  | 对传入的JAL指令，应该判定为类型2  |
| 2\.3\.4| CFI指令类型判定 | JALR判定 | 对传入的JALR指令，应该判定为类型3 |
| 2\.4\.1 | ret、call判定 | 非CFI和BR不判定       | 对传入的非CFI和BR指令，都不应判定为call或者ret                  |
| 2\.4\.2\.1\.1 | ret、call判定 | RVI\.JAL判定call | 对传入的RVI\.JAL指令，当rd设置为1或5，应当判定该指令为call          |
| 2\.4\.2\.1\.2 | ret、call判定 | RVI\.JAL例外    | 对传入的RVI\.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret |
| 2\.4\.2\.2 | ret、call判定 | RVC\.JAL不判定   | 对传入的RVC\.JAL指令，无论什么情况都不能判定为call或ret    |
| 2\.4\.3\.1\.1 | ret、call判定 | RVI\.JALR和rd为link     | 传入RVI\.JALR指令，并且rd为1或5，无论其他取值，都应判定为call     |
| 2\.4\.3\.1\.2 | ret、call判定 | RVI\.JALR且仅rs为link    | 传入RVI\.JALR指令，rd不为1和5，rs为1或5，应判定为ret        |
| 2\.4\.3\.1\.3 | ret、call判定 | RVI\.JALR无link        | 对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal |
| 2\.4\.3\.2\.1 | ret、call判定 | RVC\.JALR为Ret | 传入RVC\.JALR指令，必定为call     |
| 2\.4\.3\.2\.2\.1 | ret、call判定 | RVC\.JR且rs为link    | 传入RVC\.JR指令，rs为1或5，应判定为ret        |
| 2\.4\.3\.2\.2\.2 | ret、call判定 | RVC\.JR且rs不为link    | 传入RVC\.JR指令，rs不为1或5，不应判定为ret        |
| 2\.3\.1| 计算有效指令开始向量 | 有效指令开始向量计算1   | 对预测块，假定第一条指令为一条有效指令的开始，对每条指令计算其是否为有效指令开始  |
| 2\.3\.2| 计算有效指令开始向量 | 有效指令开始向量计算2   | 对预测块，假定第一条指令为一条有效指令的结束，对每条指令计算其是否为有效指令开始  |

</div>