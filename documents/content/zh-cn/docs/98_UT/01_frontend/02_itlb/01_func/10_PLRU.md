---
title: 支持 PLRU 替换算法
linkTitle: 10.PLRU
weight: 12
---

`LRU`（`Least Recently Used`）算法核心思想就是替换掉最近最少使用的页，也就是最长时间没有访问的页。`LRU` 算法将内存中的每个页组织成了一个链表的形式，如图所示：

![LRU 算法示意图](LRU算法.png)

链表有两端，一端是最近最少使用的页，可以称为 `LRU` 端，另一端是最近刚刚使用的页，即最近使用最频繁的页，称之为 `MRU`（`Most Recently Used`）端。每次访问的时候如果命中，那么就将命中的页移动到 `MRU` 端，如果 `miss` 则触发缺页，此时需要加载页面。如果这时候内存已满，那么就需要进行页面替换，选择 `LRU` 端的页进行替换，并把新访问的页放在 `MRU` 端。这就是 `LRU` 替换算法，是 `cache` 替换的经典算法。

但是由于 `LRU` 需要为 `cache` 行维护一个链表数据结构，在多路组相联的 `cache` 行中需要为每一路配置链表并跟踪每一行的使用时间，`LRU` 算法有着巨大的开销。因此虽然 `LRU` 在页面替换中表现出色，也依然不常使用。

在香山的昆明湖架构中，`TLB` 采用 `PLRU`（`pseudo-LRU`）替换算法，详细来说是 `tree-based PLRU` 算法。假设当前 `Cache` 是 `n` 路组相联（`n` 一般是 `2` 的整数幂）的结构，那么需要定义 `n-1` 位用来进行二叉树索引，假设为 `0` 表示左，为 `1` 表示右，如图所示：

![PLRU 二叉索引示意图](PLRU索引.png)

对目前的香山昆明湖架构来说，采用每路 `48 cache` 行的二路组相联结构下，`PLRU` 需要维护一个 `48` 项的链表和一个一级的二叉树（`1` 位），而采用 `LRU` 将需要维护一个 `48` 项的链表和 `48` 个 `2` 项的链表，有一定的开销优势，随着路数的增加，优势会更加明显；同时，对二叉树的维护成本也比链表更低。

当然，`PLRU` 多级二叉树的选择策略下并不能做到与 `LRU` 一样精确控制，每次二分地排除掉一半不一定能找到绝对 `LRU` 的条目。