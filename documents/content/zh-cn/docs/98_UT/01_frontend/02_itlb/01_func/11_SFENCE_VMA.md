---
title: 支持 SFENCE.VMA 指令
linkTitle: 11.SFENCE_VMA
weight: 12
---

`SFENCE.VMA` 指令（`Supervisor Memory-Management Fence Instruction`）是定义在 `RISC-V` 指令架构的指令：

![SFECE.VMA 指令](SFENCE_VMA.png)

在内存管理中，页表负责将虚拟地址映射到物理地址。当修改了页表后，这些修改不会自动在处理器的缓存中生效。为了确保后续的指令能使用更新后的页表，必须通过 `SFENCE.VMA` 指令来刷新这些缓存。此外，处理器在执行指令时，可能隐式地对内存管理数据结构进行读取和写入操作，但这些隐式操作和显式的内存操作通常是无序的。`SFENCE.VMA` 指令可以强制处理器将某些隐式操作在显式操作之前完成，从而确保操作的顺序性。

`SFENCE.VMA` 是 `RISC-V` 架构中的一条特权指令，用于刷新与地址翻译相关的本地硬件缓存，处理内存管理数据结构的同步，特别是当需要确保对这些数据结构的修改在不同的硬件组件之间保持一致时需要频繁使用该指令。`SFENCE.VMA` 只影响本地核心（`hart`），如果需要在多个核心之间同步，则需要核间中断等额外机制。虽然 `SFENCE.VMA` 指令对于维护一致性至关重要，但频繁调用可能会影响系统性能，因此，应根据实际需要合理使用，以平衡一致性和性能之间的关系。

`SFENCE.VMA` 的行为依赖于 `rs1` 和 `rs2`，在 `RISC-V` 特权指令集中如下所述：

| 条件                                                                                     |
|------------------------------------------------------------------------------------------|
| - 如果 `rs1=x0` 且 `rs2=x0`，栅栏会对所有地址空间的页面表的所有读写进行排序，并将所有地址翻译缓存条目标记为 invalid。 |
| - 如果 `rs1=x0` 且 `rs2` 不是 `x0`，栅栏会对指定的地址空间的页面表的所有读写进行排序，但不对全局映射进行排序。它还会失效与指定地址空间匹配的地址翻译缓存条目，但不包括全局映射的条目。 |
| - 如果 `rs1` 不是 `x0` 且 `rs2=x0`，栅栏会对所有地址空间的与 `rs1` 对应的虚拟地址的叶子页面表条目的读写进行排序，并失效包含该虚拟地址的所有叶子页面表条目的地址翻译缓存条目。 |
| - 如果 `rs1` 不是 `x0` 且 `rs2` 不是 `x0`，栅栏会对与 `rs1` 对应的虚拟地址在指定地址空间的叶子页面表条目的读写进行排序，并失效与 `rs1` 对应的虚拟地址并匹配指定地址空间的所有叶子页面表条目的地址翻译缓存条目，但不包括全局映射的条目。 |
| - 如果 `rs1` 中的值不是有效的虚拟地址，则 `SFENCE.VMA` 指令没有效果，且不会引发异常。 |
| - 当 `rs2=x0` 时，`rs2` 中的值的 `SXLEN-1:ASIDMAX` 位保留供将来标准使用。在标准扩展定义其用法之前，这些位应由软件置为零并被当前实现忽略。此外，如果 `ASIDLEN < ASIDMAX`，则实现应忽略 `rs2` 中值的 `ASIDMAX-1:ASIDLEN` 位。 |

`SFENCE.VMA` 指令的作用是确保在执行该指令之前的所有写入操作已经被提交到内存。这意味着 `Store Buffer` 中的所有未完成写入都会被写入到 `DCache` 或最终的内存地址中；`SFENCE.VMA` 发出刷新信号，通知 `MMU`（内存管理单元）更新 `TLB`（转换后备缓冲区）等内部状态。这一刷新信号是瞬时的，并且没有返回确认信号。在验证时需要通过再次访问观察是否 `miss` 的形式来进行，也可以通过分析波形文件观察 `TLB` 内部寄存器行为。

| Store Buffer（存储缓冲区）                                                   |
|------------------------------------------------------------------------------|
| Store Buffer 用于提高内存写入效率，允许 CPU 在发出写入操作后，立即继续执行后续指令，而不需要等待内存系统确认写入完成。这有助于减少 CPU 的闲置时间，提高指令执行的整体效率。写回时，写入数据首先被放入 Store Buffer，随后，数据会按某种策略写入主内存（如 DCache 或其他存储层级）。Store Buffer 维护写入操作的顺序，但不保证这些写入操作立即反映在内存中。在多核处理器中，Store Buffer 可以帮助降低缓存一致性协议的复杂性。 |